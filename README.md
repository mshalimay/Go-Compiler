# Milestone 6
The compiler is developed in the `Go` language version 1.19 using **ANTLR version 4.13.0** (not the 4.11.1 version initially provided; see below).

### Obs about ANTLR: 

As noted in this [link](https://github.com/antlr/antlr4/blob/master/doc/go-target.md), ANTLR changed the path to the Go runtimes from `github.com/antlr4-go/antlr` to `antlr4-go/antlr`

I had troubles using the ANTLR version 4.11.1 provided along with the `go` runtimes. My solution was to update the `.jar` file to the 4.13.0 version and use the new paths to the Go runtimes mentioned above. 

The `grammars` directory in the repo already contains the `antlr-4.13.0-complete.jar` and `go` `.mod` file and imports and `generate.sh` reflects the change, so there should be no problem running. I tested the setup in the UChicago CS machines, and everything is working fine.


## Usage
Below are the steps for building and running the compiler in the UChicago CS machines 

1) Load `go` version 1.19 in the CS machine using the command:
`module load golang/1.19`

2) clone the repository using 
`git clone -b m4 https://github.com/mpcs51300-sum23/proj-mashalimay`

3) Navigate to the directory where the repo was downloaded and execute `go mod tidy` to download the required dependencies



4) Building the *lexer* and *parser* using ANTLR

- Note: the repo already contains the files generated by ANTLR. 
- To reproduce the files using ANTLR autogeneration, navigate to `grammars` and execute the `generate.sh` script running: `source generate.sh`
- This will override/create new files for the parser and lexer based on the grammar rules defined in `GoliteLexer.g4` and `GoLliteParser.g4`

5) Building the compiler

- Navigate to the `golite` directory and execute `go build golite.go`
- This will build an executable called `golite`

6) Running the compiler

- To see the usage for the compiler, run: `./golite -h`

- The executable from step 5 takes the following inputs:
  - `--lex`: to run the compiler in lexer mode. This will print the program's tokens recognized by the lexer, but will not parse it.
  - `--ast`: to print the generated AST. The AST will be printed along with any semantic errors if there is any.
  - `--llvm`: to generate a `.ll` file with the translation of the source code to LLVM. Optionally can define a `target-triple` as a second argument.
  - `-s`: to generate the `s` file with the translation of source code to ARM. 
  - `-e`: to compile and execute the ARM file generated with `s`. Optionally, can provide a name to the executable with the `o` flag. Defaults to `a.out`
  - `-o`: provide a name to the executable created by the `-e` flag.
  - `path_to_file`: the full path to a `.golite` file containing a `golite` script.
  - `target-triple`: sets the target tripe for the `ll` file. Defaults to `x86_64-linux-gnu`

- To run the compiler in `lexer` mode, **from the `golite` directory**: `./golite -lex ../benchmarks/filename.golite`

- To parse the program, run `./golite ../benchmarks/filename.golite`. This will print the sintactic errors, but not the ast.

- To generate the `ll` file, run `./golite -llvm ../benchmarks/filename.golite`. This will create the file `../benchmarks/filename.ll` with the translation of the source code to LLVM. 
- To set a specific target triple, add it's string as the last argument, as in: `./golite -llvm ../benchmarks/filename.golite arm64-apple-macosx13.0.0` 

- To print the ast and parse the program, run `./golite --ast ../benchmarks/filename.golite`. This will print the ast and sintactic errors.

- obs: above assumes you are running from the `golite` directory and the original structure of the repo is mantained. You can also provide an absolute path such as `~/proj-mashalimay/benchmarks/bad1.golite`

- To generate the `.s` file, run `./golite -s ../benchmarks/filename.golite`
  - This will create the file `../benchmarks/filename.s` with the translation of the source code to ARM assembly. 

- To generate the `.s` file and compile into an executable called `myExecutable`, run: 
  - `./golite -s -e -o myExecutable ../benchmarks/filename.golite`
  - This will create the file `../benchmarks/filename.s` with the translation of the source code to ARM assembly.
  - This will create the file `../benchmarks/myExecutable.out`


# LLVM 
LLVM is fully working for all benchmarks. To verify, generate the llvm file as above and:
- navigate to the folder where the `ll` file was created. 
  - E.g.: `cd ../golite-benchmarks/thermopylae`
- compile the `ll` file using llvm tools. 
  - E.g.: `llc -filetype=asm thermopylae.ll -o thermopylae.s`
- compile the assembly file generated using `clang`. 
  - E.g.: `llc clang thermopylae.s -o thermopylae -lm -lc`
- run the file with the necessary inputs.
  - E.g.: `./thermopylae < input`


# ARM Assembly
The ARM assembly is not fully implemented, so some codes might not compile. This is why I provided the additional flag `-e`, so can generate the `.s` file without necessarily generating an executable file.




